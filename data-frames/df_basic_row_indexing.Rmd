---
jupyter:
  jupyterbook:
    show_stderr: true
  jupytext:
    formats: ''
    notebook_metadata_filter: all,-language_info
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.1
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Selecting rows from DataFrames

```{python}
# Load the Pandas data science library, call it 'pd'
import pandas as pd
# Turn on a setting to use Pandas more safely.
# We will discuss this setting later.
pd.set_option('mode.copy_on_write', True)

# Load the library for plotting, name it 'plt'
import matplotlib.pyplot as plt
# Make plots look a little more fancy
plt.style.use('fivethirtyeight')
```

We return again to the DataFrame we were working on in [basic column
indexing](df_basic_col_indexing.Rmd).

```{python}
# Original data frame before dropping missing values.
gender_data = pd.read_csv('gender_stats.csv')
gender_data_no_na = gender_data.dropna()
labeled_gdata = gender_data_no_na.set_index('country_code')
# Show the result
labeled_gdata
```

Thus far we have used indexing to select columns from DataFrames.

We also often want to select rows from DataFrames.   Two common ways of doing
that are using the `.head` and `.tail` methods, and direct indexing with
Boolean Series.


## Selecting first and last rows with `.head` and `.tail`


We have already seen that Pandas will display the data frame with nice
formatting.  If the data frame is long, it will display only the first few and
the last few rows:

```{python}
labeled_gdata
```

Notice the `...` in the center of this listing, to show that it has not printed some rows.


Sometimes we do not want to see all these rows, but only - say - the top five rows.   The `.head` method of the data frame is a useful way to do this:

```{python}
labeled_gdata.head()
```

The `Series` also has a `head` method, that does the same thing:

```{python}
# Make series by selecting a column from the DataFrame.
# We are using direct indexing with a column label
gdp = labeled_gdata['gdp_us_billion']
# Show the first 10 values.
gdp.head()
```

We can pass the `.head` method a number to display a given number of rows from the top of the DataFrame.  For example, to display the top 10 rows of the DataFrame:

```{python}
# First 10 rows.
labeled_gdata.head(10)
```

The `.tail` method works in a similar way, but displaying the last 5, or the last $n$ rows in the DataFrame:

```{python}
# Last 5 rows (the default).
labeled_gdata.tail()
```

```{python}
# Last 10 rows.
labeled_gdata.tail(10)
```

## Selecting rows by direct indexing


Another common way of selecting rows is by *indexing*.

For example, we often want to select rows from the data frame that match some
criterion.

Say we want to select the rows corresponding the countries with a high GDP.

Here's the histogram of GDP again:

```{python}
plt.hist(gdp)
```

Looking at the histogram, we could try 1000 (billion US dollars) as a threshold
to identify high GDP countries.

```{python}
high_gdp = gdp > 1000
high_gdp.head()
```

```{python}
type(high_gdp)
```

Notice that `high_gdp` is a *Boolean series*, like the Boolean arrays you have
already seen.  It has `True` for elements corresponding to countries with `gdp`
value greater than 1000 and `False` otherwise.

Notice too that the Boolean series keeps the corresponding row labels.

We can use this Boolean series to select rows from the data frame, by
*Boolean indexing*.

Call this *direct indexing with Boolean Series*.

When we index using the Boolean series inside the square brackets, it works
like this:

```{python}
rich_gender_data = labeled_gdata[high_gdp]
rich_gender_data
```

```{python}
type(rich_gender_data)
```

`rich_gender_data` is a new data frame, that is a subset of the original
`labeled_gdata` frame.  It contains only the rows where the GDP value is
greater than `1000` billion dollars.  Check the display of `rich_gender_data`
above to confirm that the values in the `gdp_us_billion` column are all
greater than `1000`.

We can do a scatter plot of GDP values against maternal
mortality rate, and we find, oddly, that for rich countries,
there is little relationship between GDP and maternal mortality.

```{python}
plt.scatter(rich_gender_data['gdp_us_billion'],
            rich_gender_data['mat_mort_ratio'])
```

One thing that stands out is the very high value at around 180.   Which country does this refer to?  We can use sorting to find out.


## Sorting data frames


Data frames have a method `sort_value`.  This returns a new data frame with the
rows sorted by the values in the column we specify.

Here are the first five rows of the data frame of the rich countries:

```{python}
rich_gender_data.head()
```

We are interested to find which of these richer countries has a high maternal mortality ratio.  To do this, we can make a new data frame where the rows are sorted by the values in the
`mat_mort_ratio` column:

```{python}
rich_by_mmr = rich_gender_data.sort_values('mat_mort_ratio')
rich_by_mmr.head()
```

Notice that the rows are in *ascending* order of `mat_mort_ratio`.  To find the countries with high maternal mortality, we might prefer to sort in *descending* order.  As usual you can explore how
you might do this by looking at the help for the `sort_values` method with:

```
rich_by_mmr.sort_values?
```

in a new cell.   If you do that, you discover the `ascending` argument, that
you can use like this:

```{python}
rich_by_descending_mmr = rich_gender_data.sort_values('mat_mort_ratio', ascending=False)
rich_by_descending_mmr.head()
```

As you might have guessed by now, `Series` also have a `sort_values` method.
For a Series, you don't have to specify the column to sort from, because you
are using the Series values.

```{python}
rich_mmr = rich_gender_data['mat_mort_ratio']
type(rich_mmr)
```

```{python}
rich_mmr.sort_values(ascending=False)
```

## Calculation on data frames


We can calculate with Pandas Series, just as we can with arrays.

For example, now we know that India has both a high GDP, and a high maternal mortality ratio, we wonder whether this is because India also has a large population, and therefore, relatively little money per person to spend on health care.

So, we would like know the GDP per capita.  Luckily the data frame as a column "population":

```{python}
rich_population = rich_by_descending_mmr["population"]
rich_population
```

We can divide the GDP by the population in millions to get US billion dollars per million population.

This works exactly as it does for arrays:

```{python}
rich_gdp = rich_by_descending_mmr["gdp_us_billion"]
rich_gdp
```

```{python}
gdp_per_million = rich_gdp / rich_population
gdp_per_million
```

Notice that the result is *elementwise* division.  Python divides each element
in `rich_gdp` by the *corresponding* element in `rich_population`.


Remember that India is the first country in the `rich_by_descending_mmr`
data frame.  It also has by far the lowest GDP per million population of
any of this selection of rich countries.   Here's a plot of
`gdp_per_million` against the corresponding values in `mat_mort_ratio`:

```{python}
plt.scatter(gdp_per_million, rich_by_descending_mmr['mat_mort_ratio'])
```

It does look as if low income per person predisposes to high maternal mortality.

